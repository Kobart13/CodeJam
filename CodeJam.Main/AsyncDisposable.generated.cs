//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#if NETSTANDARD21_OR_GREATER || NETCOREAPP30_OR_GREATER
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

using CodeJam.Internal;

using JetBrains.Annotations;

namespace CodeJam
{
	/// <summary>Helper methods for <see cref="IAsyncDisposable"/></summary>
	[PublicAPI]
	public static partial class AsyncDisposable
	{
		#region Nested types
		/// <summary>
		/// Empty <see cref="IAsyncDisposable"/> implementation.
		/// </summary>
		public sealed class EmptyAsyncDisposable : IAsyncDisposable
		{
			/// <summary>
			/// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
			/// </summary>
			public ValueTask DisposeAsync() => default;
		}

		/// DONTTOUCH: DO NOT make it a struct, passing the structure by value will result in multiple Dispose() calls.
		/// SEEALSO: https://blogs.msdn.microsoft.com/ericlippert/2011/03/14/to-box-or-not-to-box-that-is-the-question/
		private sealed class AnonymousAsyncDisposable : IAsyncDisposable
		{
			private Func<ValueTask> _disposeAction;

			public AnonymousAsyncDisposable(Func<ValueTask> disposeAction) => _disposeAction = disposeAction;

			public async ValueTask DisposeAsync()
			{
				// ReSharper disable once AssignNullToNotNullAttribute
				var disposeAction = Interlocked.Exchange(ref _disposeAction, null);
				// ReSharper disable once ConditionIsAlwaysTrueOrFalse
				if (disposeAction != null)
				{
					try
					{
						await disposeAction.Invoke();
					}
					catch when (OnException(disposeAction))
					{
					}
				}
			}

			private bool OnException(Func<ValueTask> disposeAction)
			{
				Interlocked.Exchange(ref _disposeAction, disposeAction);
				return false;
			}
		}

		/// DONTTOUCH: DO NOT make it a struct, passing the structure by value will result in multiple Dispose() calls.
		/// SEEALSO: https://blogs.msdn.microsoft.com/ericlippert/2011/03/14/to-box-or-not-to-box-that-is-the-question/
		private sealed class AnonymousAsyncDisposable<T> : IAsyncDisposable
		{
			private Func<T, ValueTask> _disposeAction;
			private T _state;

			public AnonymousAsyncDisposable(Func<T, ValueTask> disposeAction, T state)
			{
				_disposeAction = disposeAction;
				_state = state;
			}

			public async ValueTask DisposeAsync()
			{
				// ReSharper disable once AssignNullToNotNullAttribute
				var disposeAction = Interlocked.Exchange(ref _disposeAction, null);
				// ReSharper disable once ConditionIsAlwaysTrueOrFalse
				if (disposeAction != null)
				{
					try
					{
						await disposeAction.Invoke(_state);
						_state = default;
					}
					catch when (OnException(disposeAction))
					{
					}
				}
			}

			private bool OnException(Func<T, ValueTask> disposeAction)
			{
				Interlocked.Exchange(ref _disposeAction, disposeAction);
				return false;
			}
		}
		#endregion

		/// <summary>Empty <see cref="IAsyncDisposable"/> implementation.</summary>
		public static readonly EmptyAsyncDisposable Empty = new EmptyAsyncDisposable();

		/// <summary>
		/// Creates <see cref="IAsyncDisposable"/> instance that calls <paramref name="disposeAction"/> on disposing.
		/// </summary>
		/// <param name="disposeAction">The dispose action.</param>
		/// <returns>
		/// Instance of <see cref="IAsyncDisposable"/> that calls <paramref name="disposeAction"/> on disposing.
		/// </returns>
		[NotNull, Pure]
		public static IAsyncDisposable Create([NotNull] Func<ValueTask> disposeAction) => new AnonymousAsyncDisposable(disposeAction);

		/// <summary>
		/// Creates <see cref="IAsyncDisposable"/> instance that calls <paramref name="disposeAction"/> on disposing.
		/// </summary>
		/// <typeparam name="T">AsyncDisposable state type.</typeparam>
		/// <param name="disposeAction">The dispose action.</param>
		/// <param name="state">A value that contains data for the disposal action.</param>
		/// <returns>
		/// Instance of <see cref="IAsyncDisposable"/> that calls <paramref name="disposeAction"/> on disposing.
		/// </returns>
		[NotNull, Pure]
		public static IAsyncDisposable Create<T>([NotNull] Func<T, ValueTask> disposeAction, [CanBeNull] T state) => new AnonymousAsyncDisposable<T>(disposeAction, state);

		/// <summary>Combine multiple <see cref="IAsyncDisposable"/> instances into single one.</summary>
		/// <param name="disposables">The disposables.</param>
		/// <returns>Instance of <see cref="IAsyncDisposable"/> that will dispose the specified disposables.</returns>
		[NotNull, Pure]
		public static IAsyncDisposable Merge([NotNull, ItemNotNull] params IAsyncDisposable[] disposables) => Merge((IEnumerable<IAsyncDisposable>)disposables);

		/// <summary>Combine multiple <see cref="IAsyncDisposable"/> instances into single one.</summary>
		/// <param name="disposables">The disposables.</param>
		/// <returns>Instance of <see cref="IAsyncDisposable"/> that will dispose the specified disposables.</returns>
		[NotNull, Pure]
		public static IAsyncDisposable Merge([NotNull] this IEnumerable<IAsyncDisposable> disposables) =>
			Create(disposables.DisposeAllAsync);

		/// <summary>Invokes the dispose for each item in the <paramref name="disposables"/>.</summary>
		/// <param name="disposables">The multiple <see cref="IAsyncDisposable"/> instances.</param>
		/// <exception cref="AggregateException"></exception>
		public static async ValueTask DisposeAllAsync([NotNull, ItemNotNull, InstantHandle] this IEnumerable<IAsyncDisposable> disposables)
		{
			List<Exception> exceptions = null;

			foreach (var item in disposables)
			{
				try
				{
					await item.DisposeAsync();
				}
				catch (Exception ex)
				{
					exceptions ??= new List<Exception>();
					exceptions.Add(ex);
				}
			}

			if (exceptions != null)
				throw new AggregateException(exceptions);
		}

		/// <summary>Invokes the dispose for each item in the <paramref name="disposables"/>.</summary>
		/// <param name="disposables">The multiple <see cref="IAsyncDisposable"/> instances.</param>
		/// <param name="exceptionHandler">The exception handler.</param>
		public static async ValueTask DisposeAllAsync(
			[NotNull, ItemNotNull, InstantHandle] this IEnumerable<IAsyncDisposable> disposables,
			[NotNull, InstantHandle] Func<Exception, bool> exceptionHandler)
		{
			List<Exception> exceptions = null;
			foreach (var item in disposables)
			{
				try
				{
					await item.DisposeAsync();
				}
				catch (Exception ex) when (exceptionHandler(ex))
				{
					ex.LogToCodeTraceSourceOnCatch(true);
				}
				catch (Exception ex)
				{
					exceptions ??= new List<Exception>();
					exceptions.Add(ex);
				}
			}

			if (exceptions != null)
				throw new AggregateException(exceptions);
		}
	}
}
#endif