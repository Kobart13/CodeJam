<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Collections.Concurrent" #>
<#@ import namespace="System.Text.RegularExpressions" #><#+

	internal enum ReplaceMode
	{
		Normal, Swap, Ignore
	}

	internal class ReplaceInfo
	{
		public string Pattern { get; set; }
		public string Replacement { get; set; }
		public bool ThrowOnFail { get; set; }
		public bool WholeWord { get; set; }
		public bool EscapePattern { get; set; }
		public ReplaceMode Mode { get; set; }

		public bool SwapMode => Mode == ReplaceMode.Swap;
		public bool IgnoreMode => Mode == ReplaceMode.Ignore;
	}

	// ReSharper disable UnusedMember.Local
	private void Transform(string sourceFileName, ReplaceInfo[] additionalReplaces, params ReplaceInfo[] replaces)
	{
		// DONTTOUCH: additional replaces should be applied BEFORE normal replaces
		var replaceList = new List<ReplaceInfo>(additionalReplaces);
		replaceList.AddRange(replaces);
		Transform(sourceFileName, replaceList.ToArray());
	}

	private void Transform(string sourceFileName, params ReplaceInfo[] replaces)
	{
		var filePath = Host.ResolvePath(sourceFileName);
		if (!File.Exists(filePath))
		{
			throw new FileNotFoundException("File '" + filePath + "' does not exist.");
		}

		var placeholderReplaces = new ConcurrentDictionary<string, string>();
		Func<string, ReplaceInfo, string> replaceWithPlaceholdersCore = (text, replaceInfo) =>
		{
			var pattern = replaceInfo.SwapMode ? replaceInfo.Replacement : replaceInfo.Pattern;
			var replacement = replaceInfo.SwapMode ? replaceInfo.Pattern : null;
			if (replaceInfo.SwapMode || replaceInfo.EscapePattern)
			{
				pattern = Regex.Escape(pattern);
			}
			pattern = replaceInfo.WholeWord
				? @"(?<=\W|^)" +  pattern + @"(?=\W|$)"
				: pattern;

			var newText = Regex.Replace(
				text,
				pattern,
				m => placeholderReplaces.GetOrAdd(replacement ?? m.Value, _ => "%" + Guid.NewGuid() + "%"));

			if (replaceInfo.ThrowOnFail && newText == text)
				throw new InvalidOperationException("The match for " + pattern + " not found");

			return newText;
		};

		Func<string, ReplaceInfo, string> replaceCore = (text, replaceInfo) =>
		{
			var pattern = replaceInfo.Pattern;
			if (replaceInfo.SwapMode || replaceInfo.EscapePattern)
			{
				pattern = Regex.Escape(pattern);
			}
			pattern = replaceInfo.WholeWord
				? @"(?<=\W|^)" +  pattern + @"(?=\W|$)"
				: pattern;

			var newText = Regex.Replace(text, pattern, replaceInfo.Replacement);
			if (replaceInfo.ThrowOnFail && newText == text)
				throw new InvalidOperationException("The match for " + pattern + " not found");

			return newText;
		};

		var sourceText = File.ReadAllText(filePath);

		// swap-or-ignore patterns.
		foreach (var replaceInfo in replaces.Where(r => r.IgnoreMode || r.SwapMode))
		{
			sourceText = replaceWithPlaceholdersCore(sourceText, replaceInfo);
		}

		// usual replaces
		foreach (var replaceInfo in replaces.Where(r => !r.IgnoreMode))
		{
			sourceText = replaceCore(sourceText, replaceInfo);
		}

		// restore placeholders values
		foreach (var placeholderReplace in placeholderReplaces)
		{
			sourceText = sourceText.Replace(placeholderReplace.Value, placeholderReplace.Key);
		}

		Write(sourceText);
	}
#>